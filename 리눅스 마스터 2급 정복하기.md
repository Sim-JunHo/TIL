# 리눅스 마스터 2급 정복하기

---

## 01 리눅스의 이해

---

### 1.1 리눅스의 개요

#### 1.1.1 리눅스의 특징

##### 다중 사용자 및 다중 처리 시스템

하나의 시스템에 다수의 사용자들이 동시에 접속하여 사용할 수 있고 (Multi-User), 각 접속자들은 다수의 응용프로그램을 실행할 수 있다 (Multitasking)

##### 완전히 공개된 시스템

OS의 핵심인 커널 뿐만 아니라 같이 내장되어 배포되는 대부분의 응용프로그램이 오픈소스이다.

##### 뛰어난 네트워크 환경

가장 널리 쓰이는 이더넷(Ethernet), SLIP, PPP, ATM 등의 다양한 네트워크 환경을 지원하며, TCP/IP, IPX, AppleTalk 등 대부분의 네트워크 프로토콜을 지원한다.

##### 다양한 파일 시스템 지원

리눅스는 프로그램과 자료를 저장하기 위해 리눅스 고유의 파일 시스템인 ext2, ext3, ext4 등을 사용한다.
그러나 자기 고유의 파일 시스템만 지원하는 타 OS와는 달리 리눅스는 FAT(DOS), FAT32와 NFTS(windows), ISO 9660(CD-ROM), HPFS와 SCO(OS/2) 등의 다양한 상용 유닉스 파일 시스템을 지원한다.

ReisterFS, XFS, JFS 등 시스템을 복구하는 저널링 파일 시스템도 지원하고, SMB, CIFS, NFS, NCPFS등의 네트워크 파일 시스템도 지원한다.

##### 뛰어난 이식성

리눅스는 약간의 어셈과 C/C++로 작성되어 있기에 C를 컴파일할 수 있으면 어셈만 수정하고 C를 컴파일해 쉽게 타 시스템에 이식할 수 있다.

##### 유연성과 확장성

리눅스는 상업용 유닉스의 모든 특성을 지니고 있으며, 유닉스 표준인 POSIX를 준수하고 있다. 따라서 공개용 UNIX 프로그램들은 큰 문제없이 컴파일해서 사용할 수 있고, 커널, 장치드라이버, 라이브러리, 응용 프로그램, 개발도구 등 리눅스의 원시코드를 쉽게 접할 수 있다. 리눅스에서 개발된 프로그램은 다른 시스템에 이식이 쉽고, 자유로운 배포가 가능하다.

##### 뛰어난 안정성과 보안성

리눅스는 커널 소스가 공개되어 있어 Windows와 같은 폐쇄형 OS에 비해 보안상의 취약점이 쉽게 노출될 가능성은 있으나 오픈소스를 지지하는 개발자들이 상용 OS보다 빠르게 오류 수정과 보안관련 패치를 발표하고 있다.

##### 우수한 가성비

기업에서 서버로 사용되는 유닉스를 x86 시스템에 최적화시켜 설계했기 때문에 PC급 서버에서도 엔터프라이즈급의 성능 발휘.

##### 다양한 응용 프로그램의 제공

리눅스에는 OS의 핵심인 커널을 비롯해 다양한 응용프로그램을 제공함. Shell과 기본 명령어, X windows system, 편집기, 서버 및 클라 프로그램, 개발도구, 보안도구, 게임 등을 포함하여 배포하고 있다.

##### 다양한 배포판

리눅스는 서버, 개발용, PC용 등 다양한 목적으로 사용이 가능하며 이에 따른 다양한 배포판이 존재한다.
레드햇, 데비안, 우분투 등이 있으며 이러한 배포판들은 같은 리눅스 커널을 사용하지만 시스템 도구, 관리 시스템, 응용 프로그램 등이 차이가 난다. 또한 상용과 무료로 나뉘어진다.

---

#### 1.1.2 리눅스의 단점

##### 기술 지원의 부족

리눅스에서 사용되는 대부분의 응용 프로그램들이 비상업적인 제품이다. 따라서 사용하며 발생하는 문제에 책임을 지고 해결해 주는 기관이 없다.

##### 특정 하드웨어에 대한 지원이 부족하다

타 OS에 비해 이식성, 확장성 등이 뛰어나지만 여전히 특정 하드웨어의 설치는 어렵고, 모든 프로그램에서 작동하는 것은 아니다.

##### 사용자의 숙련된 기술이 요구된다.

타 OS에 비해 사용자가 직접 설정파일에 접근하고 수정하는 일이 잦아 사용자의 숙련도를 요구한다.

---

#### 1.1.3 리눅스의 기술적인 특징

##### 계층적인 파일 구조

리눅스의 파일 구조는 / (root) 를 기준으로 그 하위 디렉터리에 usr, var, bin, etc 등이 존재한다.
usr 디렉토리 밑에는 local, src 등의 디렉터리가 존재한다. 이러한 구조를 계층적 파일 구조라고 하고, 나무처럼 생겼다 하여 Tree 구조라고도 한다.

##### 장치의 파일화

장치란, 하드디스크, 키보드, 프린터, 모니터 등의 시스템에 설치된 여러 가지 하드웨어적 자원을 뜻한다. 리눅스는 이러한 장치들을 모두 파일화하여 사용하고, 특정 하드웨어에게 명령을 수행하려면 해당하는 장치 파일에 명령을 내리면 된다.

##### 가상 메모리의 사용

가상 메모리란 하드 디스크(SSD)의 일부를 메모리처럼 사용하는것을 말한다. 리눅스에서는 이 영역을 swap 이라고 부른다.

###### swapping

메모리에 올라와있지만 현재 사용하지 않는 것을 가상 메모리로 내리고, 그것을 다시 사용하려는 경우에 다시 메모리로 올린다. 이 과정의 데이터 교환을 swapping이라고 한다.

###### 스왑의 확인

설치 후 스왑 용량의 메모리 확인은 메모리 확인 명령어인 'free'를 사용하면 된다. 기본 블록 단위로 출력되므로, -m 옵션을 주면 MB단위로 사용할 수 있다.

##### 동적 라이브러리 지원

프로그램에서 특정 기능을 하는 루틴을 모아둔 것을 라이브러리라 하여 프로그램 개발 시 라이브러리 중에서 필요한 루틴들을 받아서 링크시킨다.
같은 기능의 다른 라이브러리가 실행 파일마다 들어가게 되므로 실행 파일의 크기도 커지고, 메모리도 많이 잡아먹는다. 그래서 같은 공유 라이브러리를 사용하는 것을 공용 라이브러리라 한다. 정적 라이브러리는 컴파일 시 이러한 라이브러리를 프로그램에 넣지만, 동적 공유 라이브러리는 실행 시 가져다 사용하므로 효율이 좋다.

##### 가상 콘솔

가상 콘솔은 하나의 모니터를 장착한 시스템에 여러 개의 가상 화면을 제공하는 기술이다. 리눅스는 기본적으로 6개의 가상 콘솔을 제공한다. [Ctrl]+[alt]+[F1]을 기본 시작 창으로 해서 [Ctrl]+[alt]+[F6] 까지 총 6개의 텍스트 기반의 로그인 창을 제공한다. x-windows 사용시에는 [Ctrl]+[alt]+[F7]을 통해 표시된다. x-windows 상이 아닌 가상 콘솔의 창 전환은 [alt]+[Fn] 키의 조합 만으로도 가능하다.

###### 가상 콘솔 사용 관련 팁

텍스트모드 기반의 가상 콘솔 사용시에는 이미 지나간 작업의 내용을 볼 수 없다. 그러나 최근 리눅스 배ㅗ판을 그래픽카드 메모리를 사용하여 작업 내용을 [Shift]+[Pg Up]과 [Shift]+[Pg Dn]으로 스크롤할 수 있다.

##### 파이프(Pipe)

파이프는 프로세스의 통신을 위해 도입한 것으로, 어떤 프로세스의 표준 출력이 다른 프로세스의 표준 입력으로 쓰이게 하는 것을 말한다. 리눅스에서 파이프는 '|' 기호를 사용하며, 여러개를 사용하면 파이프라인을 구성하게 되면서 데이터들은 파이프라인을 따라 흐르게 된다.
결과적으로 파이프는 여러 명령을 조합할 때 사용하고, 명령어와 명령어 사이에 | 기호를 사용한다. 또한 사용시 임시 파일이 생성되며 작업이 처리된다.

예시

- ``` $ ls | less ```
- ``` $ ls | sort | more ```

###### 표준 입출력 (Standard Input/Output)

리눅스에서는 표준 입력과 표준 출력이라는 이름의 데이터 흐름을 사용한다. 입력은 특정 프로그램으로 들어오는 값을 말하고, 출력은 특정 프로그램에서 나오는 값이다. 입력 장치에는 키보드, 파일, 스캐너 등이 사용되고, 출력 장치에는 모니터, 프린터, 파일 등이 해당한다. 다양한 입출력장치 중 기준이 되는 입력을 표준 입력이라 하는데 키보드를 말하고, 기준이 되는 출력을 표준 출력이라 하는데 모니터가 이에 해당한다.

##### 리다이렉션

리다이렉션은 어떤 프로세스의 입/출력을 표준 입출력이 아닌 다른 입출력으로 변경할 때 사용한다. 출력 결과를 파일로 저장하거나 파일의 내용을 프로세스의 입력으로 사용하는 기법이다.

- ```>``` : 프로세스의 출력을 표준 출력에서 다른 출력으로 변경한다.
- ```>>``` : 프로세스의 출력을 지정한 출력(보통 파일)에 추가한다.
- ```<``` : 프로세스의 입력을 표준 입력에서 다른 입력으로 변경한다.
- ```<<``` : 기호 뒤에 추가한 문자열을 입력으로 받아 해당 문자열이 나오기 전까지를 표준 입력을 삼아 해당 내용 출력

---

#### 1.1.4 리눅스 디렉터리 종류와 특징

##### 디렉터리(Directory)의 개요

디렉터리 : 파일을 보관하는 곳.
최상위 디렉터리인 root (/) 를 중심으로 하위 디렉터리에 다수의 디렉터리가 존재하는 트리 구조를 갖추어 계층적으로 관리됨.

##### 디렉터리 종류와 특징

| 종류        | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| /           | 최상위 디렉터리로, root 디렉터리라고 함.                     |
| /bin        | 일반적으로 binary의 약자로, 실행 파일들이 들어있다. 흔히 말하는 명령어들이 들어있는 디렉터리로, 보통 PATH가 설정되어 있다. |
| /boot       | 부팅 이미지 파일이나 커널 등 시스템 부팅 시 필요한 파일이 들어있는 디렉터리이다. 최근 사용되는 GRUB 관련 파일도 이 디렉터리에 들어있다. |
| /dev        | 하드 디스크, CD-ROM, 터미널 등과 같이 실제로 존재하는 물리적 장치 등을 파일화하여 관리하는 디렉터리. |
| /etc        | 시스템 환경 설정 파일 및 부팅과 관련된 여러가지 스크립트 파일들이 들어있다. 이들 파일을 읽어 관련 프로그램이 실행된다. |
| /home       | 개인 사용자들이 파일/디렉터리를 만들어 사용할 수 있는 홈 디렉터리가 위치. |
| /lib        | 각종 라이브러리가 저장되너 있는 디렉터리로, 커널 모듈을 포함한다. |
| /lost+found | fsck 명령어를 사용하여 파일 시스템을 복구할 때 사용하는 디렉터리. |
| /mnt        | CD-ROM, 플로피 디스크, 하드 디스크 등 파일 시스템 등을 마운트할 때 포인터가 되는 디렉터리이다. 최근 리눅스에서는 마운트할 장치가 늘어남에 따라 /media, /net 등을 추가로 사용. |
| /misc       | 자동 마운트 프로그램인 autofs에 의해 사용되는 디렉터리.      |
| /opt        | 가상 파일 시스템으로, 시스템에서 운영중인 다양한 프로세스의 상태 정보, 하드웨어 정보, 기타 시스템 정보 등을 담고있다. |
| /proc       | 가상 파일 시스템으로 시스템에서 운영되고 있는 다양한 프로세스의 상태 정보, |
| /root       | 시스템 관리자인 root 사용자의 홈 디렉토리이다.               |
| /sbin       | 'System BINary'의 약자로, 시스템 관리에 대한 명령어들이 들어있는 디렉토리이다. 주로 슈퍼유저인 root가 사용하며, 시스템 종료 명령, 네트워크 인터페이스 설정 명령, 시스템 점검/복구 등의 명령어가 들어있다. |
| /tmp        | 임시 저장 디렉토리로, 각종 프로그램, 소켓 파일, 프로세스 작업 시의 임시 파일을 저장하는 공간이다. 보통 모든 사용자의 접근이 허용된다. |
| /usr        | 시스템 운영에 필요한 명령, 응용 프로그램들이 위치해있는 디렉터리이다. 커널 소스, C 헤더, 개발 도구, X-window, 아파치, mysql, php 등이 이 디렉터리의 하위 디렉터리에 위치한다. |
| /var        | 시스템 운영 로그 파일과 스풀링과 같은 가변적인 데이터를 보관하는 디렉터리. 메일 서버로 운영시, 도착한 메일이 이 디렉토리의 하위 디렉토리에 저장된다. |

#### 1.1.5 리눅스 배포판

##### 리눅스 배포판의 개요

초기 리눅스는 커널의 지칭하였으나, 커널과 GNU 프로젝트의 라이브러리와 도구들이 포함되면서 하나의 운영체제로 발전하게 되었다.
이렇게 탄생한 리눅스를 GNU/LINUX 라고 하며 리눅스 배포판은 리눅스 커널 이외의 핵심적인 부분을 GNU 정신을 바탕으로 만들어진 다양한 자유 소프트웨어와 공개 프로그램을 모아서 하나의 OS로 만든 것이다. 기업에서 배포하는 레드햇, 우분투 등과 커뮤니티에서 배포하는 데비안, 젠투 등 300여 개의 리눅스 배포판이 존재한다.

#### 1.1.6 리눅스 관련 용어

##### GNU

GNU란 재귀적 약어인데, GNU is NOT Unix 즉 GNU는 유닉스가 아니다 라는 뜻으로, 유닉스와 호환되지만 유닉스보다 강력한 OS를 만들고자 하는 프로젝트이다. 리처드 스톨만을 중심으로 자유로운 SW를 희망하는 공동체들이 만들었다. 추기에는 자유로운 유닉스를 만드는 데에 목적이 있었으나, gcc(Gnu C Compiler), emacs, gnome 등의 응용프로그램을 만들었다.

##### FSF

Free Sw Foundation. 자유 소프트웨어 재단은 리처드 스톨만이 만든 비영리 조직으로, 자유 소프트웨어라고 해서 무료인 것은 아니고, 편집, 수정 등에서 자유롭다는 것이다.

---

## 02. 리눅스의 설치

---

### 2.2 파티션

#### 2.2.1 파티션의 개요

파티션이란, 분할, 칸막이라는 뜻으로 컴퓨터 분야에서는 하드디스크의 영역을 설정하는 것을 말한다. 기술적 의미에서 파티션은, 하나의 물리적 디스크를 여러 개의 논리적 디스크로 분할하는 것을 의미한다. 분할된 파티션은 각각 하나의 독립적인 디스크로 간주되어 블록과 파일시스템 구성 등을 독자적으로 할 수 있으며, 다양한 정책들도 독립적으로 설정할 수 있다.

- 파티션 분할의 장점
  1. 하나의 디스크에 여러 개의 OS를 사용 가능.
  2. 파티션 단위의 다양한 정책 설정이 가능하다.
  3. 사용자가 원하는 파일 시스템 설정이 가능하다. 원하는 블록의 크기의 설정을 통해 디스크 공간의 효율성을 높일 수 있다.
  4. 특정 파티션이 손상되어도 기타 파티션의 자료는 보존되기 때문에 안정성을 높일 수 있다.
  5. 자료이전 및 관리, 백업이 용이하다.
  6. 부팅이 빨라지고, 파일 시스템 점검 시간을 단축할 수 있다.
  7. 특정 영역 데이터 증가에 따른 시스템 및 프로세스의 중단을 방지할 수 있다.

위의 장점들 뿐만 아니라 가상 메모리로 사용되는 swap 영역을 파티션으로 반드시 분할해야 한다. 따라서 리눅스에서의 파티션은 리눅스 전용 파일 시스템을 위한 파티션(Linux Native Partition)과 스왑 파티션(Swap Partition)으로 나눌 수 있다.
Linux Native Partition은 실질적으로 리눅스가 설치되고 자료를 저장하기 위한 파티션으로, 줄여서 Linux Partition이라고도 한다.
Swap partition은 프로그램 실행 시 부족한 메머리의 용량을 하드디스크로 대신하는 파티션으로, 대부분의 리눅스 배포판에서 필수적으로 분할하도록 권고하고 있다.

---

#### 2.2.2 디스크와 장치명

리눅스는 모든 장치를 파일명으로 관리하기 때문에, 어떠한 디스크를 사용하는지에 따라 이름이 달라진다.
예전에는 제조사와 연결 등에 따라 분류를 하였으나, 현재는 /dev/sdx 로 관리된다.

---

#### 2.2.5 파티션의 종류

파티션의 종류에는 주 파티션(Primary Partition), 확장 파티션(Extend Partition), 논리 파티션(Logical Partition) 으로 나눈다. 주 파티션은 부팅이 가능한 파티션으로, 최대 4개까지만 설정이 가능하다. 확장 파티션은 4개 이상의 파티션 분할이 필요한 경우에 사용한다.

| 파티션의 종류     | 특징                                                         |
| ----------------- | ------------------------------------------------------------ |
| Primary Partition | - 부팅 가능한 파티션으로, 하드디스크에 하나 이상 존재해야 한다.<br />- 하나의 물리적 디스크에 총 4개까지 만들 수 있고, 파티션 번호로 1~4번이 할당된다.<br />- Extend Partition을 사용할 경우에 실질적으로 사용 가능한 Primary Partition은 3개가 된다. |
| Extend Partition  | - Extend Partition은 하나의 물리적 디스크에 1개만 생성할 수 있다.<br />- Extend Partition은 Primary Partition 영역 내에 대체해서 사용하는 것이므로, 파티션 번호도 1~4번이 할당된다<br />- Extend Partition은 자료를 저장하기 위해 직접 사용하는 파티션은 아니고, Logical Partition을 사용하기 위해 선언된다. |
| Logical Partition | - Logical Partition은 Extend Partition 안에 사용되는 파티션이다.<br />- 생성되는 개수의 제한은 없지만, 12개 이상은 권장하지 않는다.<br />- Logical Partition은 5번 이후에 번호가 붙여진다. |

---

#### 2.2.4 파티션과 장치명

분할된 파티션은 디스크 장치 파일명 뒤에 숫자가 붙어 관리된다. 일반 IDE방식 디스크인 경우에는 /dev/hda1 형식으로 생성되고, SATA, USB 메모리 등은 /dev/sda1, /dev/sdb1 등으로 생성된다.

/dev/sda1
sd : 하드디스크의 유형을 나타냄. sd는 S-ATA, SCSI방식 디스크, USB메모리를 뜻하고, hd는 IDE(ATA) 방식의 디스크를 뜻한다.
a : 디스크의 우선순위를 나타내며, a부터 시작하여 표기된다.
1 : 파티션의 번호를 나타낸다. 1~4번은 Primary 또는 Extend Partition이 할당되고, Logical Partition은 5번부터 할당된다.

---

#### 2.2.5 파티션 분할

파티션 분할이 필요한 영역과 디렉토리

- / : 리눅스 설치의 기본이 되는 영역으로, 다른 디렉터리에 대한 파티션을 분할하지 않을 경우, 이 영역으로 모든 디렉터리와 프로그램들이 설치된다.
- swap : 시스템에서 자료를 처리할때 RAM이 부족할 경우에 사용하는 SWAP 영역은 다양한 기준에 의해 크기를 설정하도록 되어 있다. 대표적인 기준으로는 RAM의 용량, 디스크의 크기, 설치된 프로그램 등이 있다.
- /boot : 부팅과 연관된 파일, GRUB 관련 파일, 시스템 커널 등이 들어있는 디렉터리이다. 별도로 파티션을 할당하는 경우, 250mb면 충분하지만, 커널 컴파일 등 커널 관련 작업이 많은 경우에는 상황에 따라 추가로 할당한다.
- /usr : 시스템의 로그 파일, 프린터 spool, 메일 등이 저장되는 디렉터리이다. 최근에는 yum을 사용할 경우에 다운로드한 업데이트 패키지들이 임시로 사용되는 용도로도 사용되고 있다.
- /home : 계정 사용자의 자료가 저장되는 디렉터리로, 다수의 사용자 기반의 서버로 운영하는 경우, 반드시 할당해야 한다. 공간의 크기는 사용자 수에 따라 적절히 변경한다.
- /tmp : 각종 프로그램, 소켓 파일, 프로세스 작업을 할 때 임시로 생성되는 파일을 저장하는 공간이다. 특히, 이 디렉터리는 시스템의 모든 사용자가 접근하여 파일을 생성 및 삭제할 수 있는 공유 모드로 설정되어 있다. 따라서 보안 강화를 위해 파티션 분할이 요청된다.

---

### 2.3 Boot Manager

#### 2.3.1 부트 매니저의 개요

부트 매니저란, 말 그대로 부팅을 도와주는 역할을 하는 프로그램으로, 멀티부팅 시에 선택하여 부팅하도록 해 준다.
부트 매니저를 BootLoader라고도 부르며, 디스크의 맨 앞쪽 영역인 MBR에 설치된다.

- 하드에 저장된 OS의 부팅 과정
  1. 전원을 켜면 바이오스는 컴퓨터에 장착된 하드웨어를 점검
  2. CMOS에 설정된 첫 번째 부팅 디스크를 확인
  3. 첫 번째 디스크의 MBR 영역에 있는 부트 매니저 프로그램 실행
  4. 부트 매니저 프로그램은 관련 환경설정 파일을 참고하여 OS 부팅을 시작한다.

---

#### 2.3.2 LILO (LInux LOader)

LILO는 리눅스용 부트 매니저 프로그램으로, 특정 파일 시스템에 구애받지 않고 부팅을 지원하였다. 초창기 리눅스 배포판에서는 LILO를 부트 매니저 프로그램으로 이용하였으나, 현재는 대부분 GRUB을 사용하고 있다. LILO는 디스크에 접근할 때, 바이오스의 정보만을 참고하는데, 초기에 설계된 바이오스의 경우, 1024개의 실린더만 인식하여 8기가 넘어가는 영역에 리눅스가 설치된 경우, 정상적으로 인식을 못 하는 경우가 발생하였다. 또한 환경 설정 파일인 /etc/lilo.conf를 수정한 뒤, 반드시 lilo 명령을 수행해야 하는 이유 등에서 현재는 사용하지 않고 있다.

---

#### 2.3.3 GRUB (GRand Unified Bootloader)

GRUB은 GNU 프로젝트에서 만든 부트로더로, LILO에 비해 다양한 파일 시스템을 지원하고, 부팅시 커널 인자를 조정하여 동적인 부팅을 지원한다.
또한 메뉴 인터페이스 방식을 기본으로 사용하지만, Bash와 같은 명령행 인터페이스를 추가로 제공하고 그래픽 메뉴와 이미지 삽입 등도 가능하다.

이외 다양한 기능을 제공하기에 많은 리눅스 배포판에서 GRUB을 사용한다.

##### GRUB의 부팅 화면

GRUB의 부트 화면은 그래픽한 메뉴 목록형식으로 제공되는데, 상하 방향키와 엔터키를 가지고 특정 OS를 선택해서 부팅이 가능하다.

##### GRUB의 부팅 모드

[a] : grub.conf 에서 kernel과 관련된 부분의 매개변수(parameter)를 추가할 수 있게 해준다.
[e] : grub.conf에 등록된 부팅 모드의 항목을 직접 편집할 수 있도록 해 준다.

- 편집 모드에서 지원하는 키
  - e : 커서가 위치한 줄 편집
  - d : 커서가 위치한 줄 삭제
  - o : 명령 줄을 커서가 위치한 줄의 아래에 추가
  - O : 명령 줄을 커서가 위치한 줄의 위에 추가
  - b : 부팅을 시작한다.

[c] : 상호 대화식으로 직접 입력할 수 있는 모드. 사용방법은 Bash Shell과 유사.

##### GRUB의 환경 설정 파일

리눅스와 윈도우를 멀티부팅한 경우 환경설정 파일인 /boot/grub/grub.conf 의 항목 값이 다음과 같이 나타난다.

```shell
#boot=/dev/sda
default=0
timeout=10
splashimage=(hd0, 3)/boot/grub/<>
title <리눅스명>	(<버젼>)
	root (hd0, 3)
	kernel /boot/<> ro root=UUID=...
	initrd /boot/<>
title DOS
	rootnoverify (hd0, 0)
	chainloader +1
```

#boot=/dev/sda
	--> 부팅이 되는 하드디스크를 지정하는 항목으로, 시스템에 장착된 하드디스크가 하나인 경우 주석처리된다.

default=0
	--> 전원을 켰을 때 기본적으로 부팅되는 OS를 설정. grub.conf에 나열된 title 순서.

timeout=10
	--> GRUB 메뉴 화면에서의 대기시간.

splashimage=(hd0, 3)/boot/grub/<>
	--> GRUB 화면의 배경 이미지를 지정하는 부분.

title <리눅스명>	(<버젼>)
	--> 리눅스 운영체제의 기본 형태.

title DOS
	--> 윈도우 운영체제의 기본 형태.

---

#### 2.3.4 로그인과 로그아웃

##### 실행 레벨 (runlevel)

리눅스의 부팅은 전원 -> BIOS 하드웨어 검사 -> GRUB 실행 -> 커널 로드 -> 파일 시스템 마운트, 점검 -> init 실행
순으로 이루어진다. init 프로세스는 시스템 부팅에 필요한 스크립트를 실행시키고 로그인 창을 호출한다. 로그인 환경은 실행레벨과 연관이 있는데, 실행레벨은 /etc/inittab 에서 정의한다. 보통 그래픽 환경에서 부팅하면 실행레벨은 5이고, 텍스트 환경이면 3이다.

---

## 03 기본 명령어

---

### 3.1 사용자 생성 및 계정 관리

---

#### 3.1.1 리눅스 명령어의 개요

리눅스의 명령어는 내부 명령어와 외부 명령어로 구분할 수 있다. 내부 명령어에는 cd, export 등이 있는데, 파일로 존재하지 않고 쉘에 내장되어 있어서 쉘이 직접 해석해서 실행해준다. 따라서 명령어 실행 시 별도의 프로세스도 발생시키지 않는다. 외부 명령어는 리눅스의 대부분을 차지하고 있는데, /bin 또는 /sbin 디렉터리에 파일 형태로 존재한다. 또한 외부 명령어를 실행하면 fork하여 새로운 서브 프로세스를 발생시킨다.

##### 명령어 검색

리눅스에서 명령어를 입력하면 쉘이 직접 해석하거나 명령어를 찾아서 실행시켜준다. 리눅스에는 수많은 디렉터리가 존재하기 때문에 전부 검색하기에는 시간이 많이 소요된다. 따라서 명령어 검색의 효율성을 높이기 위해 대부분의 명령어를 /bin, /sbin, /usr/bin 등의 디렉터리에 모아두고 지정한 디렉터리에서만 찾게끔 하고 있다. 특히 root와 일반 사용자들이 사용하는 명령어가 다르기 때문에 환경변수인 PATH를 사용해서 불필요한 디렉터리의 검색을 제한하고 있다. PATH는 사용자들이 실행 명령어를 입력했을 때 찾는 디렉터리의 목록을 저장하고 있는 환경변수이다.
검색 경로의 확인은 echo 명령어를 사용하여 확인할 수 있다.

##### 실행 명령 검색 : which

which는 실행되는 명령어의 경로를 절대 경로로 보여준다. 이 명령은 사용자가 명령을 실행시켰을 때 어떤 명령이 실행되는지를 알고 싶을 때 사용할 수 있다. 환경변수인 PATH에 등록된 경로에서만 검색하고, alias가 설정된 경우에는 설정된 내용까지 확인할 수 있다.

---

​	**alias**

​	alias란, 별명이란 뜻으로, 어떤 명령을 지정해 놓으면 사용자가 그 명령을 실행했을 떄 alias로 지정해둔 명령이 대신 실행되게 된다. 이 기능은 대부분의 쉘에서 지원하는데, 특정 명령어 실행 시에 기본으로 옵션을 사용하게 등록하거나 나만의 새로운 명령어를 만들 때 유용하게 쓰인다.

​	**alias 지정과 삭제**

- alias의 지정 : alias '명령어' = '새로운 명령'
- alias의 해제 : unalias '지정한 명령어'

---

##### 명령어 사용법

1. 명령어를 사용하는 방법에는 일정한 형식이 있다.

   1. 기본 형식

      command [options] [argument]

   2. 사용 예

      $ ls

      $ ls -alF

      $ ls /etc

      $ ls -alF /etc

2. 명령 수행 시 항목과 항목은 공백으로 구분한다.

3. 명령의 수행 결과를 옵션을 이용하여 바꿀 수 있다. 옵션은 - 또는 --를 사용하여 구분하지만 -를 권장한다. 옵션의 순서는 중요치 않고, 여러 개의 옵션을 사용하는 경우에 -다음에 붙여서 사용 가능하다.

4. 대소문자를 구분한다.

5. 파이프 (|) 를 이용해서 앞 명령어의 리턴값을 다음 명령어의 인자로 넘겨줄 수 있다.

6. 세미콜론(;), 엠퍼센드(&&), 파이프(||) 를 이용하면 다중 명령어도 실행할 수 있다.

7. [CTRL] + [C] 나  [CTRL] + [D] 를 이용하여 인터럽트를 걸 수 있다.

---

#### 3.1.2 사용자 생성 명령어

###### 사용자 계정 생성 : useradd

계정이란, 시스템에 ID와 PW를 생성하여 사용권을 부여하는 것을 말한다. 이떄 사용자의 ID를 생성하는 명령이 useradd이고, root 사용자가 root 이외의 사용자를 생성할 떄는 adduser도 가능하다.

**사용법**
	 &#35; useradd [option] 사용자 계정 이름

**주요 옵션**

| 옵션 | 의미                                                         |
| ---- | ------------------------------------------------------------ |
| -p   | 사용자의 암호를 추가 시에 저장할 수 있다.                    |
| -d   | 홈 디렉토리를 지정할 떄 쓰인다. 최총 디렉터리만 생성하므로, 중간 경로가 있는 경우에는 미리 생성해야 한다. |
| -g   | 그룹을 지정할 때 사용한다. 단, 그 그룹은 기존에 존재하는 그룹이어야 한다. |
| -G   | 기본그룹 이외 추가적으로 그룹에 속하게 할 때 쓴다.           |
| -c   | 사용자 생성 시 사용자에 대한 설명을 설정한다.                |
| -s   | 사용자 생성 시 사용자가 사용할 쉘을 지정한다.                |
| -D   | /etc/default/useradd에 설정된 유저 추가와 관련된 기본 사항들을 보여준다. |
| -m   | 사용자를 생성할 때, 홈 디렉토리를 생성해준다. 보통 -k 옵션과 함께 쓰인다. |
| -k   | 사용자 생성시에 제공되는 환경 파일들은 기본적으로 /etc/skel로 지정되어 있는데, 이외의 디렉토리를 지정할 때 쓰인다. |
| -f   | 사용자의 패스워드가 만기일을 날짜수로 지정한다               |
| -e   | 계정의 만기일을 YYYY-MM-DD 형식으로 지정한다.                |
| -u   | 사용자 추가 외에 UID 값을 지정한다.                          |

**사용 예**
	&#35; useradd 'name'
	--> 'name' 이라는 계정을 생성한다.

###### 사용자 암호 부여 : passwd

등록된 사용자의 암호를 지정하거나 변경하는 명령어. 리눅스에서 useradd로 생성한 계정에는암호를 추가해 주어야 로그인이 가능하다.

**사용법**
	$ passwd [사용자명]

**사용 예**
	$ passwd [계정명]
	--> 해당 계정의 암호를 변경한다.

###### 사용자 전환 : su

su(substitute user)는 대리 유저라는 뜻으로, 시스템에 로그인한 상황에서 다른 사용자의 권한으로 쉘을 실행할 수 있도록 전환하는 명령이다.

**사용법**
	$ su [option] [사용자명]
	--> 사용자명을 입력하지 않으면 root로 사용자 전환을 한다. 원래로 돌아가려면 exit를 입력하면 된다.

**주요 옵션**

| 옵션  | 의미                                                         |
| ----- | ------------------------------------------------------------ |
| -, -l | su 명령을 옵션 없이 실행하면 로그인한 사용자의 환경변수 ㅅ값을 가지고 다른 사람의 권한만 갖는다. |
| -c    | 사용자를 전환하지 않고 다른 사용자의 권한으로 명령을 일시적으로 수행할 때 사용된다. |

---

#### 3.1.3 사용자 관련 파일

리눅스는 대부분의 정보를 텍스트 파일에 저장해서 관리한다. 사용자 계정 정보 역시 파일에 저장되고, 사용자를 생성할 때도 관련 파일에서 정보를 가져온다.

- /etc/passwd
  /etc/passwd는 시스템에 로그인하여 자원을 이용할 수 있는 사용자의 목록을 저장하고 있는 정보 파일이다. 이 파일에 기록죈 사용자 정보는 그 사용자가 로그인하고, 로그아웃할때까지 항상 시스템이 사용자를 감시하기 위한 근거가 되는 파일이다. /etc/passwd에는 : 을 구분자로 ID 등의 7개 정보를 담고 있으며, /etc/passwd의 패스워드를 다시 암호화하여 /etc/shadow에서 추가로 관리한다.

**기본 구조**

username:password:UID:GID:fullname:home-dir:shell

- /etc/shadow
  /etc/shadow는 /etc/passwd의 두번째 필드인 패스워드 부분을 암호화하여 관리하는데 총 9개의 필드로 구성되어 있고 패스워드 만기일, 계정 만기일 등을 설정할 수 있다. 이 파일은 root만 접근 가능하다.

**기본 구조**

username:password:last:may:must:warn:expire:disable:reserved

---

#### 3.1.4 사용자 계정 관리 및 삭제

##### 사용자 계정 관리 : usermod

사용자의 쉘, 홈 디렉터리, 그룹, UID, GID 등을 변경하는 명령어로, 사용자 관련한 대부분의 정보를 변경할 수 있다.

**사용법**
\# usermod [option] 사용자계정

##### 사용자 계정 삭제 : userdel

사용자의 계정을 삭제하는 명령어이다.

**사용법**
\# userdel [option] 사용자 계정

---

#### 3.1.5 사용자 패스워드 관리

##### 사용자 패스워드 관리(1) : passwd

passwd는 기본적으로 ㅍ패스워드를 부여하거나 패스워드를 변경하는 명령이지만, 계정을 사용하지 못하게 하거나 패스워드 만기일 및 유효기간 등을 설정할 수 있다.

**사용법**
\# passwd [option] 사용자 계정

##### 사용자 패스워드 관리(2) : chage

chage는 사용자의 패스워드에 대한 정보를 출력하고 설정하는 명령이다. /etc/shadow의 날짜 관련 필드 설정을 모두 할 수 있는 명령이다.

**사용법**
\# chage [option] 사용자계정

---

#### 3.1.6 그룹 관리

##### GROUP의 개요

리눅스는 서버 OS인 UNIX의 모태로 만들어진 운영체제이다. 서버인 경우에는 하나의 시스템에 다수의 사용자가 접속해서 사용하는 환경이고, 이러한 환경에선 사용자 간의 파일 공유가 필요한 상황이 발생한다. 서버에 있는 특정 사용자끼리 파일을 공유할 때 유용한 것이 그룹이다. 공유를 원하는 사용자들을 한 그룹에 묶어서 권한 설정을 통해 파일 및 디렉터리를 공유할 수 있다. 리눅스에서 모든 사용자는 하나 이상의 그룹에 속하도록 되어 있으며, 생성 시 따로 설정하지 않으면 GID가 100인 users 그룹에 속하도록 되어있다.

##### GROUP의 조회

리눅스에 등록된 그룹의 목록은 /etc/group에서 확인할 수 있다. 그룹을 추가하면 이 파일에 등록되고, 삭제하면 이 파일 목록에서 제거된다. 또한 그룹의 팻워드도 사용자 패스워드처럼 /etc/gshadow에서 관리한다. /etc/group은 4개의 필드로 구성되어 있다.

